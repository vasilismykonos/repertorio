generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        Int                    @id @default(autoincrement())
  email                     String?                @unique
  username                  String?                @unique
  displayName               String?
  role                      UserRole               @default(USER)
  createdAt                 DateTime               @default(now())
  updatedAt                 DateTime               @updatedAt
  legacyUserId              Int?                   @unique
  avatarUrl                 String?
  profile                   Json?
  listGroupMembers          ListGroupMember[]
  listMembers               ListMember[]
  createdSongs              Song[]                 @relation("SongCreatedBy")
  songSingerTunesAsCreator  SongSingerTune[]       @relation("SongSingerTuneCreatedBy")
  createdVersions           SongVersion[]          @relation("SongVersionCreatedBy")
  singerTuneAccessAsViewer  UserSingerTuneAccess[] @relation("UserSingerTuneAccessViewer")
  singerTuneAccessAsCreator UserSingerTuneAccess[] @relation("UserSingerTuneAccessCreator")
}

model Song {
  id               Int              @id @default(autoincrement())
  legacySongId     Int?             @unique
  slug             String           @unique
  title            String
  firstLyrics      String?
  lyrics           String?
  chords           String?
  characteristics  String?
  originalKey      String?
  highestVocalNote String?
  basedOnSongId    Int?
  categoryId       Int?
  rythmId          Int?
  scoreFile        String?
  hasScore         Boolean          @default(false)
  status           SongStatus       @default(PENDING_APPROVAL)
  views            Int              @default(0)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt
  createdByUserId  Int?
  originalKeySign  String?          @db.Char(1)
  listItems        ListItem[]
  basedOnSong      Song?            @relation("SongBasedOn", fields: [basedOnSongId], references: [id])
  derivedSongs     Song[]           @relation("SongBasedOn")
  category         Category?        @relation(fields: [categoryId], references: [id])
  createdBy        User?            @relation("SongCreatedBy", fields: [createdByUserId], references: [id])
  rythm            Rythm?           @relation(fields: [rythmId], references: [id])
  SongAsset        SongAsset[]
  songCategories   SongCategory[]
  credits          SongCredit[]
  singerTunes      SongSingerTune[]
  SongTag          SongTag[]
  versions         SongVersion[]

  @@index([categoryId])
  @@index([rythmId])
  @@index([createdByUserId])
}

model SongSingerTune {
  id                    Int      @id @default(autoincrement())
  songId                Int
  createdByUserId       Int?
  tune                  String   @db.VarChar(32)
  legacyUserTuneId      Int?     @unique
  legacySongId          Int?
  singerLegacyUserId    Int?
  createdByLegacyUserId Int?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  title                 String   @db.VarChar(200)
  createdByUser         User?    @relation("SongSingerTuneCreatedBy", fields: [createdByUserId], references: [id])
  song                  Song     @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@index([songId])
  @@index([createdByUserId])
  @@index([title])
}

model SongSingerTuneMention {
  id               Int      @id @default(autoincrement())
  songSingerTuneId Int
  userId           Int
  createdAt        DateTime @default(now())

  @@unique([songSingerTuneId, userId], name: "SongSingerTuneMention_unique", map: "SongSingerTuneMention_unique")
  @@index([songSingerTuneId], map: "SongSingerTuneMention_sst_idx")
  @@index([userId], map: "SongSingerTuneMention_user_idx")
}

model UserSingerTuneAccess {
  viewerUserId  Int
  creatorUserId Int

  canView Boolean @default(true)
  canEdit Boolean @default(false)

  viewer  User @relation("UserSingerTuneAccessViewer", fields: [viewerUserId], references: [id], onDelete: Cascade)
  creator User @relation("UserSingerTuneAccessCreator", fields: [creatorUserId], references: [id], onDelete: Cascade)

  @@id([viewerUserId, creatorUserId])
  @@unique([viewerUserId, creatorUserId], name: "UserSingerTuneAccess_unique")
  @@index([viewerUserId])
  @@index([creatorUserId])
}

model Artist {
  id             Int                 @id @default(autoincrement())
  legacyArtistId Int?                @unique
  title          String
  firstName      String?
  lastName       String?
  createdAt      DateTime            @default(now())
  updatedAt      DateTime            @updatedAt
  imageUrl       String?
  biography      String?
  bornYear       Int?
  dieYear        Int?
  sex            String?
  wikiUrl        String?
  songCredits    SongCredit[]
  versionCredits SongVersionArtist[]
}

model Category {
  id             Int            @id @default(autoincrement())
  title          String         @unique
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  slug           String         @unique
  songs          Song[]
  songCategories SongCategory[]
}

model Rythm {
  id        Int      @id @default(autoincrement())
  title     String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  slug      String   @unique
  songs     Song[]
}

model SongCredit {
  id       Int            @id @default(autoincrement())
  songId   Int
  artistId Int
  role     SongCreditRole
  artist   Artist         @relation(fields: [artistId], references: [id])
  song     Song           @relation(fields: [songId], references: [id])

  @@unique([songId, artistId, role])
}

model SongVersion {
  id              Int                 @id @default(autoincrement())
  legacyVersionId Int?                @unique
  songId          Int
  title           String?
  year            Int?
  youtubeUrl      String?
  youtubeSearch   String?
  playerCode      String?
  createdAt       DateTime            @default(now())
  createdByUserId Int?
  createdByUser   User?               @relation("SongVersionCreatedBy", fields: [createdByUserId], references: [id])
  song            Song                @relation(fields: [songId], references: [id])
  artists         SongVersionArtist[]
}

model SongVersionArtist {
  id        Int               @id @default(autoincrement())
  versionId Int
  artistId  Int
  role      VersionArtistRole
  artist    Artist            @relation(fields: [artistId], references: [id])
  version   SongVersion       @relation(fields: [versionId], references: [id])

  @@unique([versionId, artistId, role])
}

model ListGroup {
  id        Int               @id @default(autoincrement())
  legacyId  Int?              @unique
  title     String
  fullTitle String?
  createdAt DateTime          @default(now())
  updatedAt DateTime          @updatedAt
  lists     List[]
  members   ListGroupMember[]
}

model List {
  id        Int          @id @default(autoincrement())
  legacyId  Int?         @unique
  title     String
  groupId   Int?
  marked    Boolean      @default(false)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt
  group     ListGroup?   @relation(fields: [groupId], references: [id])
  items     ListItem[]
  members   ListMember[]
}

model ListItem {
  id        Int     @id @default(autoincrement())
  legacyId  Int?    @unique
  listId    Int
  sortId    Int     @default(0)
  notes     String?
  transport Int     @default(0)
  title     String
  chords    String?
  lyrics    String?
  songId    Int?
  list      List    @relation(fields: [listId], references: [id])
  song      Song?   @relation(fields: [songId], references: [id])
}

model ListMember {
  id     Int            @id @default(autoincrement())
  listId Int
  userId Int
  role   ListMemberRole
  list   List           @relation(fields: [listId], references: [id])
  user   User           @relation(fields: [userId], references: [id])

  @@unique([listId, userId])
}

model ListGroupMember {
  id      Int                 @id @default(autoincrement())
  groupId Int
  userId  Int
  role    ListGroupMemberRole
  group   ListGroup           @relation(fields: [groupId], references: [id])
  user    User                @relation(fields: [userId], references: [id])

  @@unique([groupId, userId])
}

model SongCategory {
  id         Int      @id @default(autoincrement())
  songId     Int
  categoryId Int
  createdAt  DateTime @default(now())
  category   Category @relation(fields: [categoryId], references: [id])
  song       Song     @relation(fields: [songId], references: [id])

  @@unique([songId, categoryId])
}

model Asset {
  id        Int         @id @default(autoincrement())
  kind      AssetKind
  type      AssetType   @default(GENERIC)
  title     String?
  url       String?
  filePath  String?
  mimeType  String?
  sizeBytes BigInt?
  createdAt DateTime    @default(now())
  SongAsset SongAsset[]

  @@index([kind, type])
}

model SongAsset {
  songId    Int
  assetId   Int
  label     String?
  sort      Int      @default(0)
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  Asset     Asset    @relation(fields: [assetId], references: [id], onDelete: Cascade)
  Song      Song     @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@id([songId, assetId])
  @@index([assetId])
  @@index([songId, sort])
}

model SongTag {
  songId    Int
  tagId     Int
  createdAt DateTime @default(now())
  Song      Song     @relation(fields: [songId], references: [id], onDelete: Cascade)
  Tag       Tag      @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([songId, tagId])
  @@index([songId])
  @@index([tagId])
}

model Tag {
  id        Int       @id @default(autoincrement())
  title     String    @unique
  slug      String    @unique
  createdAt DateTime  @default(now())
  SongTag   SongTag[]
}

model TuneShareGroup {
  id            Int      @id @default(autoincrement())
  creatorUserId Int      @unique
  groupId       Int      @unique
  createdAt     DateTime @default(now()) @db.Timestamp(6)
  updatedAt     DateTime @default(now()) @db.Timestamp(6)
}

enum SongStatus {
  DRAFT
  PENDING_APPROVAL
  PUBLISHED
  ARCHIVED
}

enum SongCreditRole {
  COMPOSER
  LYRICIST
}

enum VersionArtistRole {
  SINGER_FRONT
  SINGER_BACK
  SOLOIST
  MUSICIAN
}

enum UserRole {
  ADMIN
  EDITOR
  AUTHOR
  CONTRIBUTOR
  USER
}

enum ListMemberRole {
  OWNER
  EDITOR
  VIEWER
}

enum ListGroupMemberRole {
  OWNER
  EDITOR
  VIEWER
}

enum AssetKind {
  FILE
  LINK
}

enum AssetType {
  GENERIC
  YOUTUBE
  SPOTIFY
  PDF
  AUDIO
  IMAGE
  SCORE
}
